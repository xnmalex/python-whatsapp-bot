from openai import OpenAI
import shelve
from dotenv import load_dotenv
import os
import time
import logging
import requests
from app.utils.message_utils import save_assistant_reply
from flask import jsonify, request

MAX_WAIT_SECONDS = 300  # 5 minutes
POLL_INTERVAL = 2       # seconds between checks
MAX_RETRIES = 3

load_dotenv()
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
OPENAI_ASSISTANT_ID = os.getenv('OPENAI_ASSISTANT_ID')

if not OPENAI_API_KEY or not OPENAI_ASSISTANT_ID:
    raise EnvironmentError("Missing OPENAI_API_KEY or OPENAI_ASSISTANT_ID")

client = OpenAI(api_key=OPENAI_API_KEY)


def upload_file(path):
    # Upload a file with an "assistants" purpose
    file = client.files.create(
        file=open("../../data/airbnb-faq.pdf", "rb"), purpose="assistants"
    )


def create_assistant(file):
    """
    You currently cannot set the temperature for Assistant via the API.
    """
    assistant = client.beta.assistants.create(
        name="WhatsApp AirBnb Assistant",
        instructions="You're a helpful WhatsApp assistant that can assist guests that are staying in our Paris AirBnb. Use your knowledge base to best respond to customer queries. If you don't know the answer, say simply that you cannot help with question and advice to contact the host directly. Be friendly and funny.",
        tools=[{"type": "retrieval"}],
        model="gpt-4-1106-preview",
        file_ids=[file.id],
    )
    return assistant


# Use context manager to ensure the shelf file is closed properly
def check_if_thread_exists(wa_id):
    with shelve.open("threads_db") as threads_shelf:
        return threads_shelf.get(wa_id, None)


def store_thread(wa_id, thread_id):
    with shelve.open("threads_db", writeback=True) as threads_shelf:
        threads_shelf[wa_id] = thread_id


def run_assistant_background(thread, name, callback=None):
    try:
        # Step 1: Create a run for the thread
        run = client.beta.threads.runs.create(
            thread_id=thread.id,
            assistant_id=OPENAI_ASSISTANT_ID
        )
        run_id = run.id
        start_time = time.time()
        logging.info(f"Started assistant run {run_id} for thread {thread.id}")

        # Step 2: Poll until completed or timeout
        while run.status != "completed" and time.time() - start_time < MAX_WAIT_SECONDS:
            time.sleep(POLL_INTERVAL)
            run = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
            logging.info(f"Polling run {run.id}: status = {run.status}")

            if run.status in ["failed", "cancelled", "expired"]:
                error_info = getattr(run, "last_error", None)
                error_message = getattr(error_info, "message", "Unknown error") if error_info else "No error details"
                logging.warning(f"Run failed | status: {run.status} | reason: {error_message}")
                return f"Assistant failed: {error_message}"

        # Step 3: Cancel if timeout hit
        if run.status != "completed":
            logging.error(f"Timeout hit. Cancelling run {run.id}...")
            try:
                client.beta.threads.runs.cancel(thread_id=thread.id, run_id=run.id)
            except Exception as cancel_err:
                logging.warning(f"Could not cancel run: {cancel_err}")
            return "Assistant timed out. Please try again."

        # Step 4: Retrieve final message
        messages = client.beta.threads.messages.list(thread_id=thread.id)
        for message in messages.data:
            if message.role == "assistant":
                for content in message.content:
                    if content.type == "text":
                        logging.info("Assistant reply retrieved successfully.")
                        if callback:
                            save_assistant_reply(thread.id, content.text.value)
                            return callback(content.text.value)

        logging.warning("No assistant reply found in message list.")
        return "No reply generated by the assistant."

    except Exception as e:
        logging.error(f"Exception in run_assistant: {e}")
        return "An unexpected error occurred."


def generate_response(message_body, wa_id, name, image_path=None, file_path=None):
    # Check if there is already a thread_id for the wa_id
    thread_id = check_if_thread_exists(wa_id)
    file_id = None

    # If a thread doesn't exist, create one and store it
    if thread_id is None:
        logging.info(f"Creating new thread for {name} with wa_id {wa_id}")
        thread = client.beta.threads.create()
        store_thread(wa_id, thread.id)
        thread_id = thread.id

    # Otherwise, retrieve the existing thread
    else:
        logging.info(f"Retrieving existing thread for {name} with wa_id {wa_id}")
        thread = client.beta.threads.retrieve(thread_id)
        
    logging.info(f"Retrieving image path {image_path} with file_path {file_path}")
    # Step 2: Prepare message content
    if image_path:
        
        message_content = [
            {"type": "text", "text": message_body or "Please describe this image."},
            {"type": "image_url", "image_url": {"url": image_path}}
        ]
    elif file_path:
        message_content = [
            {"type": "text", "text": message_body or "Please describe this document."},
        ]
        
        logging.info(f"file path for open ai: {file_path}")
        response = requests.get(file_path)
        response.raise_for_status()
        
        # Save temp file
        with open("temp.pdf", "wb") as f:
            f.write(response.content)
        
        with open("temp.pdf", "rb") as f:
            file = client.files.create(file=f, purpose="assistants")
            file_id = file.id
    else:
        message_content = message_body
        
    # Add message to thread
    message_params = {
        "thread_id": thread_id,
        "role": "user",
        "content": message_content,
    }
    if file_id:
        message_params["attachments"] = [{"file_id": file_id, "tools": [{"type": "file_search"}, {"type": "code_interpreter"}]}]
        
    logging.info(f"[OpenAI] Sending message with params: {message_params}")
    message = client.beta.threads.messages.create(**message_params)
    # Run the assistant and get the new message
    return thread, name

def list_assistant():
    try:
        assistants = client.beta.assistants.list().data
        assistant_list = [a.model_dump() for a in assistants]
        return jsonify(assistant_list), 200
    except Exception as err:
        logging.error(f"error getting assistant data {err} type {type(err)}")
        return jsonify({"status": "error", "message": "bad request"}), 400

def create_assistant():
    data = request.get_json()
    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400

    allowed_keys = is_valid_data()
    unknown_keys = set(data.keys()) - allowed_keys
    if unknown_keys:
        return jsonify({"error": f"Unknown fields in request: {list(unknown_keys)}"}), 400

    try:
        # Create an assistant
        assistant = client.beta.assistants.create(
            **{k: v for k, v in data.items() if k in allowed_keys}
        )
            
        logging.info(f"Assistant created: {assistant.name}, ID: {assistant.id}")
        return jsonify({"status": "success", "message": f"Assistant created: {assistant.name}, ID: {assistant.id}"}), 200
    except Exception as err:
        logging.error(f"error getting assistant data {err} type {type(err)}")
        return jsonify({"status": "error", "message": f"bad request{err}"}), 400
       
    
def delete_assistant(assistant_id):
    try:
        if assistant_id:
            # Delete the assistant
            assistant = client.beta.assistants.delete(assistant_id)
            
            logging.info(f"Assistant deleted ID: {assistant.id}")
            return jsonify({"status": "success", "message": f"Assistant deleted ID: {assistant.id}"}), 200
           
        else:
            return jsonify({"status": "error", "message": "invalid body"}), 200
    
    except Exception as err:
        logging.error(f"error getting assistant data {err} type {type(err)}")
        return jsonify({"status": "error", "message": f"bad request{err}"}), 400
    
def update_assistant(assistant_id):
    data = request.get_json()

    if not data:
        return jsonify({"error": "Invalid JSON payload"}), 400
       
    logging.info(f"request body: {data}")

    allowed_keys = is_valid_data()
    unknown_keys = set(data.keys()) - allowed_keys
    if unknown_keys:
        return jsonify({"error": f"Unknown fields in request: {list(unknown_keys)}"}), 400
        
    # Update an assistant
    try:
        assistant = client.beta.assistants.update(
                assistant_id=assistant_id,
                **{k: v for k, v in data.items() if k in allowed_keys}
        )
                
        logging.info(f"Assistant updated ID: {assistant.id}")
        return jsonify({"status": "success", "message": f"Assistant updated ID: {assistant.id}"}), 200
    except Exception as err:
        logging.error(f"error getting assistant data {err} type {type(err)}")
        return jsonify({"status": "error", "message": f"bad request{err}"}), 400
           
    
def is_valid_data():
    allowed_keys = {'name', 'instructions', 'model', 'tools', 'metadata', 'description'}
    return allowed_keys
           
def cancel_run_assistant():
    data = request.get_json()
    thread_id = data.get("thread_id")
    run_id = data.get("run_id")

    if not thread_id or not run_id:
        return jsonify({"error": "thread_id and run_id are required"}), 400

    try:
        result = client.beta.threads.runs.cancel(
            thread_id=thread_id,
            run_id=run_id
        )
        logging.info(f"Run {run_id} in thread {thread_id} has been cancelled.")
        return jsonify({
            "status": "cancelled",
            "thread_id": thread_id,
            "run_id": run_id
        }), 200
    except Exception as e:
        logging.error(f"[CANCEL ERROR] {e}")
        return jsonify({"error": str(e)}), 500